# Welcome to Loom
Loom is a small workflow system in Python. The primary reason for creating Loom is to replace GNU Make to be compatible on systems that are naturally deprived of this wonder of human inginuity. Design goals are:

- Ease of use: simple interface using TOML or JSON to configure.
- Ease of installation: only Python needed (and Rich for pretty printing).
- Stay minimal: don't give in to feature bloat.

## How it works
You give Loom a list of tasks that may depend on one another. Loom will run these when input files are newer than the target. Execution is lazy and in parallel. Loom supports:

- Running tasks by passing a script to any configured interpreter, e.g. Bash or Python.
- Redirecting `stdout` or `stdin` to or from files.
- Defining so called "phony" targets.
- Define `pattern` for programmable reuse. Other than with GNU Make, these patterns are not automatically triggered for matching targets, rather you need to explicitely instantiate them.
- Include other Loom files, even ones that need to be generated by another task. You can imagine some script expanding tasks so they become part of a larger workflow.
- `stdin` and `stdout` are automatic dependency and target.

### Example 1: Rot13
To write out "Hello, World!" to a file `msg.txt`, we may do the following,

``` {.toml #rot13-secret}
[[task]]
stdout = "secret.txt"
language = "Python"
script = """
print("Uryyb, Jbeyq!")
"""
```

To have this message decoded define a pattern,

``` {.toml #rot13-pattern}
[pattern.rot13]
stdout = "{stdout}"
stdin = "{stdin}"
language = "Bash"
script = """
tr a-zA-Z n-za-mN-ZA-M
"""

[[call]]
pattern = "rot13"
  [call.args]
  stdin = "secret.txt"
  stdout = "msg.txt"
```

To define a phony target "all",

``` {.toml file=examples/rot13.toml}
[[task]]
name = "all"
dependencies = ["msg.txt"]

<<rot13-secret>>
<<rot13-pattern>>
```

``` {.bash .eval}
loom examples/rot13.toml 
```

Features on the roadmap:
- Defining "tmpfile" targets.
- Enable Jinja in patterns.
- Specify that certain tasks should not run in parallel by having a named set of semaphores.
- Enable versioned output directory (maybe Jinja solves this)


Loom executes workflows in Asyncio, through lazy evaluation and memoization.
The `Lazy` class contains a `asyncio.lock` and a `Result` object. When multiple
tasks ask for the result of the same dependent task, the lock makes sure a
computation is perforemed only once. Once the lock is free, all future requests
immediately return the memoized result.

      .------.        .------. 
     |  Lazy  | -->  |  Task  |
      `------'        `------' 

      .--------.        .--------. 
     |  LazyDB  | -->  |  TaskDB  |
      `--------'        `--------' 



``` {.python file=loom/__init__.py}
from .program import Program, resolve_tasks
from .task import Task, TaskDB

__all__ = ["Program", "resolve_tasks", "Task", "TaskDB"]
```


``` {.python file=loom/logging.py}
import logging


def logger():
    return logging.getLogger("loom")
```

``` {.python file=loom/cli.py}
from argparse import ArgumentParser
from pathlib import Path
import re
from typing import Optional
import argh  # type: ignore
import asyncio

from loom.utility import read_from_file
from rich_argparse import RichHelpFormatter

from .program import Program, resolve_tasks
from .logging import logger

log = logger()


async def main(
    program: Program, target_strs: list[str], force_run: bool, throttle: Optional[int]
):
    db = await resolve_tasks(program)
    for t in db.tasks:
        log.debug(str(t))
    if throttle:
        db.throttle = asyncio.Semaphore(throttle)
    db.force_run = force_run
    await asyncio.gather(*(db.run_name(t) for t in target_strs))


@argh.arg(
    "path",
    help="Loom TOML or JSON file, use a `[...]` suffix to indicate a subsection.",
)
@argh.arg("targets", nargs="+", help="name of targets to run")
@argh.arg("-B", "--force-run", help="rebuild all dependencies")
@argh.arg("-j", "--jobs", help="limit number of concurrent jobs")
def loom(
    path: str, targets: list[str], force_run: bool = False, jobs: Optional[int] = None
):
    """Build one of the configured targets."""
    if m := re.match(path, r"([^\[\]]+)\[([^\[\]\s]+)\]"):
        input_path = Path(m.group(1))
        section = m.group(2)
    else:
        input_path = Path(path)
        section = None

    program = read_from_file(Program, input_path, section)
    asyncio.run(main(program, targets, force_run, jobs))


def cli():
    parser = ArgumentParser(formatter_class=RichHelpFormatter)
    argh.set_default_command(parser, loom)
    argh.dispatch(parser)


if __name__ == "__main__":
    cli()
```
