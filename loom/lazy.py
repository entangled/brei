# ~/~ begin <<docs/lazy.md#loom/lazy.py>>[init]
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Generic, Iterable, Optional, Self, TypeVar
import asyncio

from loom.errors import HelpfulUserError
from loom.utility import FromStr

from .result import Result, Ok, DependencyFailure, TaskFailure, MissingFailure

T = TypeVar("T")
R = TypeVar("R")


@dataclass
class Phony(FromStr):
    name: str

    @classmethod
    def from_str(cls, s: str) -> Phony:
        if s[0] == "#":
            return Phony(s[1:])
        raise ValueError("A phony target should start with a `#` character.")

    def __str__(self):
        return f"#{self.name}"


@dataclass
class Lazy(Generic[T, R]):
    """Base class for tasks that are tagged with type `T` (usually `str` or
    `Path`) and representing values of type `R`.

    To implement a specific task, you need to implement the asynchronous
    `run` method, which should return a value of `R` or throw `TaskFailure`.

    Attributes:
        targets: list of target identifiers, for instance paths that are
            generated by running a particular task.
        dependencies: list of dependency identifiers. All of these need to
            be realized before the task can run.
        result (property): value of the result, once the task was run. This
            throws an exception if accessed before the task is complete.
    """

    targets: list[T]
    dependencies: list[Phony | T]
    name: Optional[str] = None

    _lock: asyncio.Lock = field(default_factory=asyncio.Lock, init=False)
    _result: Optional[Result[R]] = field(default=None, init=False)

    @property
    def real_dependencies(self) -> list[T]:
        return [d for d in self.dependencies if not isinstance(d, Phony)]

    def __bool__(self):
        return self._result is not None and bool(self._result)

    @property
    def result(self) -> R:
        if self._result is None:
            raise ValueError("Task has not run yet.")
        if not self._result:
            raise ValueError("Task has failed.")
        assert isinstance(self._result, Ok)
        return self._result.value

    async def run(self) -> R:
        raise NotImplementedError()

    async def run_after_deps(self, recurse, *args) -> Result[R]:
        dep_res = await asyncio.gather(*(recurse(dep) for dep in self.dependencies))
        if not all(dep_res):
            return DependencyFailure(
                {k: v for (k, v) in zip(self.dependencies, dep_res) if not v}
            )
        try:
            return Ok(await self.run(*args))
        except TaskFailure as f:
            return f

    async def run_cached(self, recurse, *args) -> Result[R]:
        async with self._lock:
            if self._result is not None:
                return self._result
            self._result = await self.run_after_deps(recurse, *args)
            return self._result

    def reset(self):
        self._result = None


TaskT = TypeVar("TaskT", bound=Lazy)


class MissingDependency(Exception):
    pass


@dataclass
class LazyDB(Generic[T, TaskT]):
    """Collect tasks and coordinate running a task from a task identifier."""

    tasks: list[TaskT] = field(default_factory=list)
    index: dict[T, TaskT] = field(default_factory=dict)
    name_index: dict[str, TaskT] = field(default_factory=dict)

    async def run(self, t: Phony | T, *args) -> Result[R]:
        if isinstance(t, Phony):
            return await self.run_name(t.name, *args)

        if t not in self.index:
            try:
                task = self.on_missing(t)
            except MissingDependency:
                return MissingFailure(t)
        else:
            task = self.index[t]
        return await task.run_cached(self.run, *args)

    async def run_name(self, t: str, *args) -> Result[R]:
        if t not in self.name_index:
            raise HelpfulUserError(f"Task `#{t}` not found.")
        return await self.name_index[t].run_cached(self.run, *args)

    def on_missing(self, _: T) -> TaskT:
        raise MissingDependency()

    def add(self, task: TaskT):
        """Add a task to the DB."""
        self.tasks.append(task)
        for target in task.targets:
            self.index[target] = task
        if task.name:
            self.name_index[task.name] = task

    def clean(self):
        self.tasks = []
        self.index = {}

    def reset(self):
        for t in self.tasks:
            t.reset()
# ~/~ end
